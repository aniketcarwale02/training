REST API :
  why GET for read operations, POST for create, PUT for update, DELETE for delete?
        ğŸ”¹ GET â†’ Read
        âœ… Deep Reason:
        Safe: GET must not change the server state â€” it's designed to only read data.

        Idempotent: Multiple identical GET requests = same result.

        Cacheable: Proxies and browsers know GET is safe, so they cache aggressively.

        URL-based: Easy to bookmark, share, index by search engines, etc.

        Imagine if every time you visited a blog post, the server updated the database â€” that would be insane. GET ensures read-only access.

        ğŸ”’ Security Implication:
        CSRF attacks are harder with GET because it's meant to be non-mutative.

        No sensitive data in query string.

        ğŸ”¹ POST â†’ Create
        âœ… Deep Reason:
        Non-idempotent: Creating the same record twice results in two new records.

        Carries data in body: Ideal for larger or sensitive payloads.

        Triggers a change: Posts signal â€œDo somethingâ€ â€” save to DB, send email, etc.

        If you're submitting a new user registration or posting a message â€” you're creating a resource, so POST makes sense.

        ğŸš« Why not use GET for this?
        URLs would contain user data (?name=John&password=123) â€” insecure and limitable.

        Can be cached/replayed â€” leads to accidental duplication.

        ğŸ”¹ PUT â†’ Update
        âœ… Deep Reason:
        Idempotent: Repeating a PUT with the same data results in the same final state.

        Complete replacement: PUT usually means â€œreplace the resource at this URIâ€.

        Imagine you update your profile â€” sending the whole object (PUT /users/123) makes sense.

        âœ³ï¸ Idempotency Is Key:
        With retries (e.g., if the network drops), you donâ€™t want side effects.

        Safe to repeat: update user name 5 times with the same payload = same result.

        ğŸ”¹ DELETE â†’ Delete
        âœ… Deep Reason:
        Idempotent: Deleting the same resource repeatedly results in "gone".

        Semantic clarity: Clients, caches, tools (like Postman or browsers) know exactly what this is doing.

        If you delete a user account: whether you send DELETE /users/123 once or five times, the user should be gone.

        ğŸ›¡ System Design Impact:
        Server knows how to log, audit, or restrict destructive actions.
        Middleware like API Gateways can intercept DELETE for extra auth checks.

        ğŸ”„ Why We Care About These Differences
        1. Scalability
        CDNs and caches work best with GET (because itâ€™s predictable).

        Knowing POST mutates data lets load balancers avoid caching it.

        2. Safety & Idempotency
        With PUT and DELETE, clients can safely retry after failure.

        With POST, retries must be handled carefully to avoid duplication.

        3. Auditing & Logging
        You can trace who created vs updated vs deleted a resource just by HTTP verb.

        4. Security & Authorization
        Role-based access can be verb-specific (e.g., â€œthis user can GET but not DELETEâ€).

        Firewalls and API Gateways can inspect and allow/deny methods differently.

